\documentclass[usenames,dvipsnames]{beamer}
\usepackage{pgfpages}
\setbeameroption{show notes on second screen=right}
\setbeamertemplate{note page}[plain]
\usepackage{tikz}
\usetikzlibrary{cd}
\usepackage{catchfilebetweentags}
\usepackage{amssymb}
\usepackage{turnstile}
\usepackage{bbm}
\usepackage[greek, english]{babel}
\usepackage{MnSymbol}
\usepackage{stmaryrd}
\usepackage{csquotes}
\newcommand\doubleplus{+\kern-1.3ex+\kern0.8ex}
\newcommand\mdoubleplus{\ensuremath{\mathbin{+\mkern-8mu+}}}
\makeatletter
\newcommand\incircbin
{%
  \mathpalette\@incircbin
}
\newcommand\@incircbin[2]
{%
  \mathbin%
  {%
    \ooalign{\hidewidth$#1#2$\hidewidth\crcr$#1\bigcirc$}%
  }%
}
\newcommand{\oeq}{\ensuremath{\incircbin{=}}}
\makeatother
\usepackage{ucs}
\DeclareUnicodeCharacter{8759}{\ensuremath{\squaredots}}
\DeclareUnicodeCharacter{951}{\textgreek{\texteta}}
\DeclareUnicodeCharacter{737}{\ensuremath{^\text{l}}}
\DeclareUnicodeCharacter{691}{\ensuremath{^\text{r}}}
\DeclareUnicodeCharacter{7523}{\ensuremath{_\text{r}}}
\DeclareUnicodeCharacter{8718}{\ensuremath{\blacksquare}}
\DeclareUnicodeCharacter{957}{\textgreek{\textnu}}
\DeclareUnicodeCharacter{961}{\textgreek{\textrho}}
\DeclareUnicodeCharacter{929}{\textgreek{\textRho}}
\DeclareUnicodeCharacter{954}{\textgreek{\textkappa}}
\DeclareUnicodeCharacter{10214}{\ensuremath{\lsem}}
\DeclareUnicodeCharacter{10215}{\ensuremath{\rsem}}
\DeclareUnicodeCharacter{8857}{\mdoubleplus}
\DeclareUnicodeCharacter{8860}{\oeq}
\DeclareUnicodeCharacter{9043}{\ensuremath{\triangle}}
\DeclareUnicodeCharacter{928}{\textgreek{\textPi}}
\DeclareUnicodeCharacter{922}{\textgreek{\textKappa}}
\DeclareUnicodeCharacter{931}{\textgreek{\textSigma}}
\DeclareUnicodeCharacter{916}{\textgreek{\textDelta}}
\DeclareUnicodeCharacter{8779}{\ensuremath{\backtriplesim}}
\DeclareUnicodeCharacter{8799}{\ensuremath{\stackrel{?}{=}}}
\DeclareUnicodeCharacter{10181}{\ensuremath{\lbag}}
\DeclareUnicodeCharacter{10182}{\ensuremath{\rbag}}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{autofe}
\usepackage[references]{agda}
\usepackage{bbding}
\setlength{\marginparwidth}{2cm}
\usepackage[obeyDraft]{todonotes}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{decorations.pathmorphing}
\usetikzlibrary{snakes}
\usetikzlibrary{arrows}
\usepackage{forest}
\usepackage{multicol}
\usetheme{metropolis}
\usepackage{natbib}
\usepackage{bibentry}
\usepackage[draft=false]{minted}
\usepackage{amsmath}
\usepackage{tabularx}
\metroset{block=fill}
\title{Talking About Mathematics in a Programming Language}
\author{Donnacha Oisín Kidney}
\begin{document}
\maketitle
\tableofcontents
\bibliographystyle{plain}
\nobibliography{../horners-rule.bib}
\section{What do we want from a Language for Mathematics?}
\begin{frame}
  \frametitle{What do we want from a Language for Mathematics?}
  \note<1>{
    As it turns out, the languages we use for maths already look a little like
    programming languages.

    In designing them we encounter a lot of the same goals.
  }
  \pause
  \begin{columns}[T]
    \column{0.5\textwidth}
    \begin{block}{A \emph{Syntax} that is}
      \begin{itemize}
        \item Readable
        \item Precise
        \item Terse
      \end{itemize}
    \end{block}
    \pause
    \column{0.5\textwidth}
    \begin{block}{\emph{Semantics} that are}
      \note<3>{
        Semantics/axiomatic core
      }
      \begin{itemize}
        \item Small
        \item Powerful
        \item Consistent
      \end{itemize}
    \end{block}
  \end{columns}
  \note<3>{
    Some of these are conflicting!
  }
\end{frame}
\begin{frame}[standout]
  Why not use a Programming Language?
\end{frame}
\begin{frame}
  \frametitle{Reason 1: Because Computer-Assisted Proofs are ``Bad''}
  \note<1>{
    Aren't computer-assisted proofs bad? Inelegant? Less rigorous?
  }

  \pause
  \bibentry{appel_solution_1977}
  \note<2>{
    The famous example is the four-colour map theorem.

    First major mathematical proof which relied heavily on computer assistance.

    The problem is thus: can you colour a map, with only four colours, so that
    every border has two different colours?

    The proof effectively relied on checking a large number of different
    cases---a computer program was used to check each one.
  }
  \pause
  \begin{itemize}
  \item Non-Surveyable
    \pause
    \note<3>{
      The proof is too large for another mathematician to check its work! (that
      is, after all, why a computer was used)
    }
  \item Doesn't Provide Insight
    \pause
    \note<4>{
      This is maybe an aesthetic concern, but the prevailing attitude is that a
      non computer-assisted proof would provide a deeper understanding of the
      problem, and more general tools to be used later, rather than a simple
      statement ``yes the proposition is true'' or ``no it's false''.

      Of course, in practice, working a proof to a level where it becomes
      solvable via a computer requires insight in and of itself, but perhaps
      less insight than another method.
    }

  \item Requires Trust
    \note<5>{
      We have to believe that the program used to prove the proposition doesn't
      contain bugs!
    }
  \end{itemize}
  \pause
  Did contain bugs!
  \note<6>{
    Although they weren't critical to the correctness.
  }
\end{frame}
\begin{frame}
  \frametitle{This is Different}
  \pause
  We're looking for a core set of axioms/semantics and a syntax to talk about
  mathematics
  \note<2>{
    We're going to use PL theory to help get us there
  }
  
  \pause
  If we do it right, it should be so simple that ``even a computer could
  understand it''
  \note<3>{
    But this is incidental!

    The real work is in finding the language that works.

    Even now, most compilers for these languages are grad students!
  }


  \pause
  \begin{block}{Why would we want a computer to understand our language?}
    \pause
    \begin{itemize}
      \item So it can check our proofs! \pause
      \item So it can check our \emph{automated} proofs!
    \end{itemize}
  \end{block}

  \note<5>{
    If a machine can read your proofs, then it can \emph{check} your proofs.

    This adds a level of rigour that you just don't get with handwritten proofs.
  }
  \note<6>{
    A perfect candidate for the kinds of proofs we'd like a machine to check
    \emph{are} computer-assisted proofs.

    Remember, our language is a programming language: write the automated
    theorem prover in it, and then \emph{verify} the theorem prover in it!
  }

  \pause
  \bibentry{gonthier_formal_2008}
  \note<7>{
    Unfortunately, this is still difficult to do

    The formalized version of the four-colour theorem came out a full 29 years
    later!
  }
\end{frame}
\begin{frame}[fragile]
  \frametitle{Reason 2: Haven't We Tried This Before?}
  \note<1>{
    Fully formalizing mathematics from the ground-up has long been a goal.
    (Hilbert)

    Haven't other attempts failed?
  }
  \begin{columns}
    \column{0.5\linewidth}
    \onslide<2->{
      \bibentry{whitehead_principia_1910} p. 379
    }
    \column{0.5\linewidth}
    \onslide<4->{\alert{Formal systems have improved}}
  \end{columns}
  \note<2>{
    This is the citation for Whitehead and Russell's proof of the fact that
    1+1=2 

    Is a formalization really going to be \emph{this} tedious?
  }
  \note<4>{
    We have much better formalisms now.

    Although they're still tedious, they're nowhere near the verbosity of
    principia.
  }

  \vfill
  
  \begin{columns}
    \column{0.5\linewidth}
    \onslide<3->{Gödel showed that universal formal systems are incomplete}
    \column{0.5\linewidth}
    \onslide<5->{\alert{We don't need universal systems}}
  \end{columns}

  \note<3>{
    Besides---hasn't it been shown to be impossible, anyway?
  }
  \note<5>{
    A universal system is too powerful---we can get by with less.

    Law of the Excluded Middle
  }

  \vfill

  \bibentry{paulson2016future}
\end{frame}
\begin{frame}[fragile]
  \frametitle{Why Would a Programmer Want to Use this Language?}
  \note<1>{
    Suppose I convince you that this formalism is good enough to do maths---is
    it good enough to do \emph{programming}? Surely the two aims are orthogonal?

    While most languages for ``proving'' these days are indeed not suitable for
    general-purpose programming, ideas from them are leaking into mainstream
    languages.

    And, of course, Idris is a general-purpose language which can prove as good
    as anything!
  }
  \begin{itemize}
    \item<2-> \emph{Prove} things about code \note<2>{Not just test!}
    \item<3-> Use ideas and concepts from maths---why reinvent them?
      \note<3>{Mathematics and formal language has existed for thousands of years;
        programming has existed for only 60!}
    \item<4-> Provide coherent \emph{justification} for language features
  \end{itemize}
  \begin{overlayarea}{\linewidth}{0cm}
    \begin{onlyenv}<2>
      \centering
      \begin{minipage}{0.7\linewidth}
        \begin{minted}[autogobble]{python}
          assert(list(reversed([1,2,3])) == [3,2,1])
        \end{minted}
      \end{minipage}

      \emph{vs}

      \ExecuteMetaData[BasicTypes.tex]{reverse-props}
    \end{onlyenv}
  \end{overlayarea}
\end{frame}
\section{Programming is Proving}
\begin{frame}[fragile]
  \frametitle{The Curry-Howard Correspondence}
  \note<1>{
    To use a programming language as a proof language, we'll need to see how
    programming constructs map on to constructs in logic.

    This ``mapping'' is known as the curry-howard correspondence (or
    isomorphism).
  }
  \note<2>{
    Here's the high-level overview.

    ``Program'' here just means anything with a type, basically. In \(x = 2\), x
    is a program, and 2 is a program, and so on. Functions are programs, etc.
    We could have also said ``value'' or something, but program is the word used
    in the literature.
  }
  \begin{onlyenv}<2->
    \begin{figure}
      \centering
      \begin{tikzcd}
        Type    \ar[d] \ar[r, Leftrightarrow] & Proposition \ar[d] \\
        Program \ar[r, Leftrightarrow]        & Proof
      \end{tikzcd}
    \end{figure}
  \end{onlyenv}
  \vfill
  \bibentry{wadler_propositions_2015-1}
\end{frame}
\begin{frame}
  \frametitle{Types are Propositions}
  Types are (usually):
  \begin{itemize}
    \item \(\AgdaDatatype{Int}\)
    \item \(\AgdaDatatype{String}\)
    \item ...
  \end{itemize}

  How are these propositions?
  \note{Propositions are things like ``there are infinite primes'', etc. Int
    certainly doesn't \emph{look} like a proposition.}
\end{frame}
\begin{frame}[fragile]
  \frametitle{Existential Proofs}
  \note<1>{We use a trick to translate: put a ``there exists'' before the type.}
  \pause
  \begin{columns}[T]
    \column{0.5\textwidth}
    \centering
    So when you see:
    \ExecuteMetaData[BasicTypes.tex]{xint}
    \column{0.5\textwidth}
    \centering
    \pause
    Think:
    \[\exists. \mathbb{N}\]
  \end{columns}
  \pause

  \begin{block}{NB}
    We'll see a more powerful and precise version of \(\exists\) later.
  \end{block}

  \pause
  Proof is ``by example'':

  \pause
  \ExecuteMetaData[BasicTypes.tex]{xprf}
\end{frame}
\begin{frame}[fragile]
  \frametitle{Programs are Proofs}
  \note<1>{Let's start working with a function as if it were a proof. The function
    we'll choose gets the first element from a list. It's commonly called
    ``head'' in functional programming.}
  \pause
  \begin{minted}{haskell}
    >>> head [1,2,3]
    1
  \end{minted}
  \pause

  Here's the type:
  \ExecuteMetaData[BasicTypes.tex]{headty}
\end{frame}
\begin{frame}[fragile]
  \frametitle{Basic Agda Syntax}
  \note<1>{\(\AgdaFunction{head}\) is what would be called a ``generic''
    function in languages like Java. In other words, the type \(A\) is not
    specified in the implementation of the function.}

  \pause
  Equivalent in other languages:

  \begin{description}
    \item[Haskell]
      \begin{minted}{haskell}
        head :: [a] -> a
      \end{minted}
    \item[Swift]
      \begin{minted}{swift}
        func head<A>(xs : [A]) -> A {
      \end{minted}
  \end{description}

  \pause
  \note<3>{In Agda, you must supply the type to the function: the curly brackets
    mean the argument is implicit.}
  \begin{columns}
    \column{0.5\textwidth}
    \ExecuteMetaData[BasicTypes.tex]{headty}
    \pause
    \column{0.5\textwidth}
    ``Takes a list of things, and returns one of those things''.
  \end{columns}

\end{frame}
\begin{frame}[fragile]
  \frametitle{The Proposition is False!}
  \begin{minted}{haskell}
    >>> head []
    error "head: empty list"
  \end{minted}
  \note<1>{head isn't defined on the empty list, so the function \emph{doesn't}
    exist. In other words, its type is a false proposition.}
  \pause

  \begin{columns}
    \column{0.5\textwidth}
    \ExecuteMetaData[BasicTypes.tex]{headty}
    \pause
    \column{0.5\textwidth}
    \centering
    \alert{False}
  \end{columns}
\end{frame}
\begin{frame}
  If Agda is correct (as a formal logic):

  \only<2>{\alert{We shouldn't be able to prove this using Agda}}
  \only<3>{\alert{We shouldn't be able write this function in Agda}}
\end{frame}
\begin{frame}[fragile]
  \frametitle{But Let's Try Anyway!}
  \only<1>{
    Function definition syntax

    \note{Agda functions are defined (usually) with \emph{pattern-matching}. For
      the natural numbers, we use the Peano numbers, which gives us 2 patterns:
      zero, and successor.}
    \ExecuteMetaData[BasicTypes.tex]{fib}
  }

  \only<2>{
    \note{For lists, we also have two patterns: the empty list, and the head
      element followed by the rest of the list.}

    \ExecuteMetaData[BasicTypes.tex]{length}
  }
  \only<3->{
    \ExecuteMetaData[BasicTypes.tex]{head1}
    \onslide<6->{\ExecuteMetaData[BasicTypes.tex]{head2}}
    \note<3>{
      Here's a candidate definition for head.

      Remember, we shouldn't be able to write it, so if this definition is
      accepted by Agda, then Agda isn't correct.

      So how do we disallow it?
    }
    \note<4>{
      We disallow it because it doesn't match all patterns.

      Agda will only accept functions which are defined for \emph{all} of their
      inputs.
    }
    \note<5>{
      So we need something to write for the second clause, the empty list.

      It seems like we can't, but people familiar with Haskell may have spotted a
      way to do it.
    }
    \note<6>{
      In Haskell, a definition like this is perfectly acceptable: it's just
      recursive.

      Here, though, we've obviously proved a falsehood, so we need some way to
      disallow it.

      If we were to run this program, it would just loop forever: disallowing that
      turns out to be enough to keep the logic consistent.
    }

    \onslide<4->{
      \begin{block}{Rule 1}
        No partial functions
      \end{block}
    }
    \onslide<7->{
      \begin{block}{Rule 2}
        All programs are total
      \end{block}
    }
    \note<7>{
      Bear in mind that even if we don't obey the rules the program can still be
      a valid proof---we just have to run it first.

      Obeying these rules ensures that the proofs are valid if they typecheck.
      
      What does ``total'' mean? Well, it's something like terminating...
    }
}
\end{frame}
\begin{frame}
  \frametitle{Turing Completeness}
  \pause
  \note<1>{
    Have we just thrown out Turing completeness?

    If we're not allowed infinite loops, then we're not turing complete, right?

    Well, no...
  }
  The dual to termination is \emph{productivity}
  \note<2>{
    Consider a program like a webserver, or a clock on your computer.

    Neither of these things should ``terminate'', but we don't want them to
    contain infinite loops, either.

    The property we want them to posses is called \emph{productivity}: they
    always produce another step of computation in finite time, even if there are
    infinitely many steps.

    Agda can check for productivity, too.
  }
  \pause
  \ExecuteMetaData[BasicTypes.tex]{stream}
  \note<3>{
    The definition of this type (and the coinductive keyword) change the
    behaviour of the termination-checker. We can now construct infinite
    structures.

    Using types like this, we can (for instance), simulate a turing machine, or
    write a lambda-calculus interpreter.

    What we \emph{can't} do is lie about the types of those programs: we won't
    be able to write a function like ``run'' which produces a finite result. We
    could write a function that runs for some finite number of steps, and
    produces a finite result, or a function which produces an infinite result,
    though.
  }
  \pause
  You can write terminating and non-terminating programs: \emph{you just have to
  say so}
\end{frame}
\begin{frame}
  \note<1>{
    Enough Restrictions!

    That's a lot of things we \emph{can't} prove.

    How about something that we can?

    How about the converse?
  }
  \pause
  Can we \emph{prove} that \(\AgdaFunction{head}\) doesn't exist?

  \note<2>{
    After all, all we have so far is ``proof by trying really hard''.
  }
\end{frame}
\begin{frame}
  \frametitle{Falsehood}
  \note<1>{First we'll need a notion of ``False''. Often it's said that you can't
    prove negatives in dependently typed programming: not true! We'll use the
    principle of explosion: ``A false thing is one that can be used to prove
    anything''.}

  \begin{columns}
    \column{0.5\textwidth}<3->
    \ExecuteMetaData[BasicTypes.tex]{false}
    \column{0.5\textwidth}<2->
    \begin{block}{Principle of Explosion}
      \emph{``Ex falso quodlibet''} \\
      If you stand for nothing, you'll fall for anything.
    \end{block}
  \end{columns}
\end{frame}
\begin{frame}
  \ExecuteMetaData[BasicTypes.tex]{head-not}

  \note{Here's how the proof works: for falsehood, we need to prove the supplied
    proposition, no matter what it is. If \(\AgdaFunction{head}\) exists, this
    is no problem! Just get the head of a list of proofs of the proposition,
    which can be empty.}
\end{frame}
\begin{frame}
  \frametitle{Proofs are Programs}
  \note<1>{
    So that was an attempt to show that programs are proofs, if you look at them
    funny.

    Now let's go the other direction: let's see what some constructs in proof
    theory look like when translated into programming.
  }
  \pause
  Types/Propositions are \emph{sets}

  \ExecuteMetaData[BasicTypes.tex]{bool-def}

  \pause
  Inhabited by \emph{proofs}

  \begin{table}
    \begin{tabular}{ll}
      \(\AgdaDatatype{Bool}\) & Proposition \\
      \(\AgdaInductiveConstructor{true}\), \(\AgdaInductiveConstructor{false}\) & Proof
    \end{tabular}
  \end{table}
\end{frame}
\begin{frame}
  \frametitle{Implication}
  \note<1>{Just a function arrow}
  \pause
  \begin{columns}
    \column{0.5\linewidth}
    \ExecuteMetaData[BasicTypes.tex]{impl}
    \pause
    \column{0.5\linewidth}
    \(\AgdaDatatype{A}\) implies \(\AgdaDatatype{B}\)
    \pause
  \end{columns}

  Constructivist/Intuitionistic
  \note<4>{Give me a proof of a, I'll give you a proof of b}
\end{frame}
\begin{frame}
  \frametitle{Booleans?}
  \note<1>{
    We \emph{don't} use bools to express truth and falsehood.

    Bool is just a set with two values: nothing ``true'' or ``false'' about
    either of them!

    This is the difference between using a computer to do maths and \emph{doing
      maths in a programming language}
  }
  \pause
  \note<2>{
    Falsehood (contradiction) is the proposition with no proofs.

    It's equivalent to what we had previously.
  }
  \begin{columns}
    \column{0.5\linewidth}
    \ExecuteMetaData[BasicTypes.tex]{bot-def}
    \column{0.5\linewidth}
    Contradiction
  \end{columns}
  \note<3>{
    In fact, we can convert from what we had previously
  }
  \note<4>{
    And \emph{to} what we had previously.

    Here, we use an impossible pattern.
  }
  \only<3-4>{
    \ExecuteMetaData[BasicTypes.tex]{poe-to-bot}
  }

  \only<4>{
    \ExecuteMetaData[BasicTypes.tex]{bot-to-poe}
  }

  \pause
  \pause
  \pause
  \begin{columns}
    \column{0.5\linewidth}
    \ExecuteMetaData[BasicTypes.tex]{top-def}
    \column{0.5\linewidth}
    Tautology
  \end{columns}
  \note<5>{
    Tautology is kind of the ``boring'' type.
  }
\end{frame}
\begin{frame}[fragile]
  \frametitle{Conjunction}
  \note<1>{
    Conjunction (``and'') is represented as a data type.
  }
  \pause
  \ExecuteMetaData[BasicTypes.tex]{prod-record}
  \note<2>{
    It has two type parameters, and two fields.
  }
  \begin{overlayarea}{\textwidth}{7cm}
    \begin{onlyenv}<3>
      \begin{columns}[T]
        \column{0.5\linewidth}
        \begin{block}{Swift}
          \begin{minted}[autogobble]{Swift}
            struct Pair<A,B>{
              let fst: A
              let snd: B
            }
          \end{minted}
        \end{block}
        \column{0.5\linewidth}
        \begin{block}{Python}
          \begin{minted}[autogobble]{Python}
            class Pair:
              def __init__(self, x, y):
                self.fst = x
                self.snd = y
          \end{minted}
        \end{block}
      \end{columns}
    \end{onlyenv}
    \note<3>{
      Syntax-wise, it's equivalent to a \emph{class} in other languages.
    }
    \begin{onlyenv}<4>
      \ExecuteMetaData[BasicTypes.tex]{prod}
    \end{onlyenv}
    \note<4>{
      We could also have written it like this. (Haskell-style)

      The definition is basically equivalent, but we don't get two field accessors
      (we'd have to define them manually) and some of the syntax is better suited
      to the record form.

      It does show the type of the constructor, though (which is the same in
      both).

      It's curried, which you don't need to understand: just think of it as taking
      two arguments.

      ``If you have a proof of A, and a proof of B, you have a proof of A
      \emph{and} B''
    }
    \begin{onlyenv}<5>
      \begin{block}{Type Theory}
        2-Tuple
      \end{block}
    \end{onlyenv}
    \begin{onlyenv}<6>
      \begin{block}{Set Theory}
        Cartesian Product
        \[\{t, f\} \times \{1, 2, 3\} = \{(t, 1), (f, 1), (t, 2), (f, 2), (t, 3),
          (f, 3)\} \]
      \end{block}
    \end{onlyenv}
    \begin{onlyenv}<7>
      Familiar identities: conjunction-elimination
      \begin{columns}
        \column{0.5\textwidth}
        \ExecuteMetaData[BasicTypes.tex]{cnj-elim}
        \column{0.5\textwidth}
        \[A \wedge B \implies A\]
      \end{columns}
    \end{onlyenv}
  \end{overlayarea}
\end{frame}
\begin{frame}[fragile]
  \frametitle{Currying}
  \note{
    Just a short note on currying.

    People familiar with Haskell will know what it is, I won't explain it in its
    entirety here, though. Just a little interesting thing on how it translates
    into logic.
  }
  \begin{onlyenv}<2>
    \ExecuteMetaData[BasicTypes.tex]{curry}
  \end{onlyenv}

  \only<3-6>{
    \begin{table}
      \begin{tabularx}{\textwidth}{XX}
        \only<3-6>{The type:              } & \only<4-6>{Is isomorphic to:                  }  \\
        \only<3-6>{\(A , B \rightarrow C\)} & \only<4-6>{\(A \rightarrow (B \rightarrow C)\)}  \\[1cm]
        \only<5-6>{Because the statement: } & \only<6>{Is the same as saying:             }  \\
        \only<5-6>{``A and B implies C''  } & \only<6>{``A implies B implies C''          }
      \end{tabularx}
    \end{table}
  }

  \only<7-8>{
    ``If I'm outside and it's raining, I'm going to get wet''
    \[Outside \wedge Raining \implies Wet\]

    \onslide<8>{
      ``When I'm outside, if it's raining I'm going to get wet''
      \[Outside \implies Raining \implies Wet\]
    }
  }
\end{frame}
\begin{frame}
  \frametitle{Disjunction}
  \ExecuteMetaData[BasicTypes.tex]{disj}
\end{frame}
\begin{frame}
  \frametitle{Dependent Types}
  \pause
  Everything so far has been non-dependent

  \pause
  Proving things using this bare-bones toolbox is difficult (though possible)

  \pause
  To make things easier, we're going to add some things to our types
  \note<2>{
    In other words, lots of modern languages support it. (Haskell)
  }

  \note<3>{
    The proof that head doesn't exists, for instance, could be written in
    vanilla Haskell.

    It's difficult to prove more complex statements using this pretty bare-bones
    toolbox, though, so we're going to introduce some extra handy features.
  }

  \bibentry{martin-lof_intuitionistic_1980}
\end{frame}
\begin{frame}
  \frametitle{The \(\Pi\) Type}

  \note<1>{
    First, we upgrade the function arrow, so the right-hand-side can talk about
    the value on the left.
  }
  \pause
  Upgrade the \emph{function arrow}
  \note<2>{
    This lets us easily express \emph{properties}
  }
  \pause
  \ExecuteMetaData[BasicTypes.tex]{pi-example}
  \pause

  Now we have a proper \(\forall\)
\end{frame}
\begin{frame}
  \frametitle{The \(\Sigma\) Type}
  \pause
  Upgrade \emph{product types}

  \pause
  \ExecuteMetaData[BasicTypes.tex]{sigma-example}

  \note<3>{
    Later fields can refer to earlier ones.
  }
  \pause
  Now we have a proper \(\exists\)
\end{frame}
\begin{frame}
  \frametitle{The Equality Type}
  \ExecuteMetaData[BasicTypes.tex]{eq-example}
  \note{
    Final piece of the puzzle.

    The type of this type has 2 parameters.

    But the only way to construct the type is if the two parameters are the
    same.

    You then get evidence of their sameness when you pattern-match on that
    constructor.
  }
\end{frame}
\begin{frame}
  \frametitle{Equality}
  \note<1>{
    Agda uses propositional equality

    You can construct the equality proof when it's obvious.
  }
  \ExecuteMetaData[BasicTypes.tex]{plus-def}
  \ExecuteMetaData[BasicTypes.tex]{plus-obvious}
  \pause
  \note<2>{
    you need to supply the proof yourself when it's not obvious.
  }
  \ExecuteMetaData[BasicTypes.tex]{plus-not-obvious}
\end{frame}
\begin{frame}
  \frametitle{Open Areas and Weirdness}
  \note<1>{
    To keep the logic consistent, we need to lose a few things. (These are the
    things we lose when we get rid of ``universalness'')
  }
  \only<2-3>{
    \begin{block}{Law of the Excluded Middle}
      ``For any proposition, either it's true or its negation is true''

      \onslide<3>{\ExecuteMetaData[BasicTypes.tex]{lem}}
    \end{block}
  }
  \note<2>{
    While this may seem obvious, it's not provable in our logic!

    Proving it would be the equivalent to taking a question, and finding the
    answer to it: this is fundamentally undecidable in the general case.
  }
  \only<4-7>{
    \begin{block}{Russell's Paradox}
      ``The Set of all Sets which do not contain themselves''

      \onslide<5->{\bibentry{girard_interpretation_1972}}
      \begin{columns}
        \column{0.5\textwidth}
        \onslide<6->{\ExecuteMetaData[BasicTypes.tex]{not}}
        \column{0.5\textwidth}
        \onslide<7>{\ExecuteMetaData[BasicTypes.tex]{neg}}
      \end{columns}
  \end{block}
  }
  \note<4>{
    One of the things that tripped up early logicians is Russell's paradox.
  }
  \note<5>{
    In type theory, it's called Girard's paradox.
  }
  \note<6>{
    Remember that types are defined as sets. Bool is a set, int is a set, etc.

    Values have types, and types are sets. Bool -> Bool, for instance, is the
    type of not. Bool -> Bool is a Set.
  }
  \note<7>{
    However, we've already broken this boundary: The type of negation was Set ->
    Set. Is Set -> Set a type?

    There are other examples: List is a function of type Set -> Set.

    Fine. So ``neg'' has the type Set -> Set. Here's the question, though: is
    Set -> Set a Set?

    We've allowed a set to be a member of itself, opening the door to russell's
    paradox.

    There are a number of different ways to avoid it; in Agda, all types are
    ``Set''s. Set -> Set, though, is a Set1. Set1 -> Set1 is a Set2. And so on.
  }
  \only<8>{
    \begin{block}{Function Extensionality/Data Constructor Injectivity}
      \ExecuteMetaData[BasicTypes.tex]{ext}
    \end{block}
  }
  \note<8>{
    Again, seems like something you should be able to do.

    But all of these small rules around equality are very much in flux: if you
    grant constructor Injectivity (a very similar rule to this one), you can
    prove a contradiction!

    Other systems, such as Homotopy type theory, observational equality, and so
    on, have very different ideas about equality. 
  }
\end{frame}
\section{A Polynomial Solver}
\section{The \(p\)-Adics}
\end{document}
