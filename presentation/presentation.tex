\documentclass[usenames,dvipsnames]{beamer}
\usepackage{tikz}
\usetikzlibrary{cd}
\usepackage{catchfilebetweentags}
\usepackage{amssymb}
\usepackage{turnstile}
\usepackage{bbm}
\usepackage[greek, english]{babel}
\usepackage{MnSymbol}
\usepackage{stmaryrd}
\usepackage{csquotes}
\newcommand\doubleplus{+\kern-1.3ex+\kern0.8ex}
\newcommand\mdoubleplus{\ensuremath{\mathbin{+\mkern-8mu+}}}
\makeatletter
\newcommand\incircbin
{%
  \mathpalette\@incircbin
}
\newcommand\@incircbin[2]
{%
  \mathbin%
  {%
    \ooalign{\hidewidth$#1#2$\hidewidth\crcr$#1\bigcirc$}%
  }%
}
\newcommand{\oeq}{\ensuremath{\incircbin{=}}}
\makeatother
\usepackage{ucs}
\DeclareUnicodeCharacter{8759}{\ensuremath{\squaredots}}
\DeclareUnicodeCharacter{951}{\textgreek{\texteta}}
\DeclareUnicodeCharacter{737}{\ensuremath{^\text{l}}}
\DeclareUnicodeCharacter{691}{\ensuremath{^\text{r}}}
\DeclareUnicodeCharacter{7523}{\ensuremath{_\text{r}}}
\DeclareUnicodeCharacter{8718}{\ensuremath{\blacksquare}}
\DeclareUnicodeCharacter{957}{\textgreek{\textnu}}
\DeclareUnicodeCharacter{961}{\textgreek{\textrho}}
\DeclareUnicodeCharacter{929}{\textgreek{\textRho}}
\DeclareUnicodeCharacter{954}{\textgreek{\textkappa}}
\DeclareUnicodeCharacter{10214}{\ensuremath{\lsem}}
\DeclareUnicodeCharacter{10215}{\ensuremath{\rsem}}
\DeclareUnicodeCharacter{8857}{\mdoubleplus}
\DeclareUnicodeCharacter{8860}{\oeq}
\DeclareUnicodeCharacter{9043}{\ensuremath{\triangle}}
\DeclareUnicodeCharacter{928}{\textgreek{\textPi}}
\DeclareUnicodeCharacter{922}{\textgreek{\textKappa}}
\DeclareUnicodeCharacter{931}{\textgreek{\textSigma}}
\DeclareUnicodeCharacter{916}{\textgreek{\textDelta}}
\DeclareUnicodeCharacter{8779}{\ensuremath{\backtriplesim}}
\DeclareUnicodeCharacter{8799}{\ensuremath{\stackrel{?}{=}}}
\DeclareUnicodeCharacter{10181}{\ensuremath{\lbag}}
\DeclareUnicodeCharacter{10182}{\ensuremath{\rbag}}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{autofe}
\usepackage[references]{agda}
\usepackage{bbding}
\setlength{\marginparwidth}{2cm}
\usepackage[obeyDraft]{todonotes}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{decorations.pathmorphing}
\usetikzlibrary{snakes}
\usetikzlibrary{arrows}
\usepackage{forest}
\usepackage{multicol}
\usetheme{metropolis}
\usepackage{natbib}
\usepackage{bibentry}
\usepackage[draft=false]{minted}
\title{Programming Mathematics in Agda}
\author{Donnacha Oisín Kidney}
\begin{document}
\maketitle
\tableofcontents
\bibliographystyle{plain}
\nobibliography{../horners-rule.bib}
\section{What do Programming Languages Have to Say About Mathematics?}
\begin{frame}
  Languages for proofs and languages for programs have a lot of the same requirements.

  \pause
  \begin{columns}[T]
    \column{0.5\textwidth}
    \begin{block}{A \emph{Syntax} that is}
      \begin{itemize}
        \item Readable
        \item Precise
        \item Terse
      \end{itemize}
    \end{block}
    \pause
    \column{0.5\textwidth}
    \begin{block}{\emph{Semantics} that are}
      \note{Semantics/axiomatic core}
      \begin{itemize}
        \item Small
        \item Powerful
        \item Consistent
      \end{itemize}
    \end{block}
  \end{columns}
  \note{Some of these are conflicting!}
\end{frame}
\begin{frame}[standout]
  Why not use a programming language as our proof language?
\end{frame}
\begin{frame}[fragile]
  \frametitle{Benefits For Programmers}
  \begin{itemize}
    \item<2-> \emph{Prove} things about code \note{Not just test!}
    \item<3-> Use ideas and concepts from maths---why reinvent them?
      \note{Mathematics and formal language has existed for thousands of years;
        programming has existed for only 60!}
    \item<4-> Provide coherent \emph{justification} for language features
  \end{itemize}
  \begin{overlayarea}{\linewidth}{0cm}
    \begin{onlyenv}<2>
      \centering
      \begin{minipage}{0.7\linewidth}
        \begin{minted}[autogobble]{python}
          assert(list(reversed([1,2,3])) == [3,2,1])
        \end{minted}
      \end{minipage}

      \emph{vs}

      \ExecuteMetaData[BasicTypes.tex]{reverse-props}
    \end{onlyenv}
  \end{overlayarea}
\end{frame}
\begin{frame}
  \frametitle{Benefits For Mathematicians}
  \begin{itemize}
    \item<2-> Have a machine check your proofs
    \item<3-> Run your proofs
    \item<4-> \alert<5>{Develop a consistent foundation for maths}
  \end{itemize}

  \begin{overlayarea}{\linewidth}{1cm}
    \only<2>{Currently, though, this is \emph{tedious}}
    \only<5>{Wait---isn't this impossible?}
  \end{overlayarea}
\end{frame}
\begin{frame}[fragile]
  \frametitle{Formalizing Mathematics}
  \begin{columns}
    \column{0.5\linewidth}
    \onslide<2->{Whitehead and Russell took \emph{hundreds} of pages to prove \(1+1=2\)}
    \column{0.5\linewidth}
    \onslide<4->{\alert{Formal systems have improved}}
  \end{columns}

  \vfill
  
  \begin{columns}
    \column{0.5\linewidth}
    \onslide<3->{Gödel showed that universal formal systems are incomplete}
    \column{0.5\linewidth}
    \onslide<5->{\alert{We don't need universal systems}}
  \end{columns}

  \vfill

  \bibentry{paulson2016future}
\end{frame}
\begin{frame}
  \frametitle{What About Automated Theorem Provers?}
  \note{
    Use a combination of heuristics and exhaustive search to check some
    proposition.

    \alert{Non Surveyable}

    \emph{We have to trust the implementation.}
  }
  \pause
  Appel and Haken's 1976 proof of the Four-Color Theorem

  \note{\emph{Not} what we're doing here!}

  \pause
  This is about picking a set of axioms and syntax so simple that \emph{even a
    computer} could understand them.

  \note{Unfortunately, proofs in this setting are often long and tedious. But
    rigorous! (Although not quite as bad as Principia)}

  \pause
  Formalized proof of the Four-Colour theorem arrived a full \emph{29 years}
  later!

  \bibentry{gonthier_formal_2008}

  \pause

  Since our proof language is \emph{executable}, maybe we can write
  \emph{verified} automated theorem provers?
\end{frame}
\section{Programming is Proving}
\begin{frame}[fragile]
  \frametitle{The Curry-Howard Correspondence}
  \begin{figure}
    \centering
    \begin{tikzcd}
      Type    \ar[d] \ar[r, Leftrightarrow] & Proposition \ar[d] \\
      Program \ar[r, Leftrightarrow]        & Proof
    \end{tikzcd}
  \end{figure}
  \bibentry{wadler_propositions_2015-1}
\end{frame}
\begin{frame}
  \frametitle{Types are Propositions}
  Types are (usually):
  \begin{itemize}
    \item \(\AgdaDatatype{Int}\)
    \item \(\AgdaDatatype{String}\)
    \item ...
  \end{itemize}

  How are these propositions?
  \note{Propositions are things like ``there are infinite primes'', etc. Int
    certainly doesn't \emph{look} like a proposition.}
\end{frame}
\begin{frame}[fragile]
  \frametitle{Existential Proofs}
  \note{We use a trick to translate: put a ``there exists'' before the type.}
  \pause
  \begin{columns}[T]
    \column{0.5\textwidth}
    \centering
    So when you see:
    \ExecuteMetaData[BasicTypes.tex]{xint}
    \column{0.5\textwidth}
    \centering
    \pause
    Think:
    \[\exists. \mathbb{N}\]
  \end{columns}
  \pause

  \begin{block}{NB}
    We'll see a more powerful and precise version of \(\exists\) later.
  \end{block}

  \pause
  Proof is ``by example'':

  \pause
  \ExecuteMetaData[BasicTypes.tex]{xprf}
\end{frame}
\begin{frame}[fragile]
  \frametitle{Programs are Proofs}
  \note{Let's start working with a function as if it were a proof. The function
    we'll choose gets the first element from a list. It's commonly called
    ``head'' in functional programming.}
  \pause
  \begin{minted}{haskell}
    >>> head [1,2,3]
    1
  \end{minted}
  \pause

  Here's the type:
  \ExecuteMetaData[BasicTypes.tex]{headty}
\end{frame}
\begin{frame}[fragile]

  \frametitle{Basic Agda Syntax}
  \pause
  \note{\(\AgdaFunction{head}\) is what would be called a ``generic'' function
    in languages like Java.}

  \pause
  Equivalent in other languages:

  \begin{description}
    \item[Haskell]
      \begin{minted}{haskell}
        head :: [a] -> a
      \end{minted}
    \item[Swift]
      \begin{minted}{swift}
        func head<A>(xs : [A]) -> A {
      \end{minted}
  \end{description}

  \pause
  \note{In other words, the type \(A\) is not specified in the implementation of
    the function.}

  \begin{columns}
    \column{0.5\textwidth}
    \ExecuteMetaData[BasicTypes.tex]{headty}
    \pause
    \column{0.5\textwidth}
    ``Takes a list of things, and returns one of those things''.
  \end{columns}

  \note{In Agda, you must supply the type to the function: the curly brackets
    mean the argument is implicit.}
\end{frame}
\begin{frame}[fragile]
  \frametitle{The Proposition is False!}
  \begin{minted}{haskell}
    >>> head []
    error "head: empty list"
  \end{minted}
  \note{head isn't defined on the empty list, so the function \emph{doesn't}
    exist. In other words, its type is a false proposition.}
  \pause

  \begin{columns}
    \column{0.5\textwidth}
    \ExecuteMetaData[BasicTypes.tex]{headty}
    \pause
    \column{0.5\textwidth}
    \centering
    \alert{False}
  \end{columns}
\end{frame}
\begin{frame}
  If Agda is correct (as a formal logic):

  \only<2>{\alert{We shouldn't be able to prove this using Agda}}
  \only<3>{\alert{We shouldn't be able write this function in Agda}}
\end{frame}
\begin{frame}[allowframebreaks]
  \frametitle{But Let's Try Anyway!}
  Function definition syntax

  \note{Agda functions are defined (usually) with \emph{pattern-matching}.}

  \ExecuteMetaData[BasicTypes.tex]{fib}

  \note{For the natural numbers, we use the Peano numbers, which gives us 2
    patterns: zero, and successor.}

  \framebreak

  \note{For lists, we also have two patterns: the empty list, and the head
    element followed by the rest of the list.}

  \ExecuteMetaData[BasicTypes.tex]{length}

  \framebreak

  Here's a definition for \(\AgdaFunction{head}\):

  \ExecuteMetaData[BasicTypes.tex]{head1}

  \begin{block}{\alert{No!}}
    For correct proofs, partial functions aren't allowed
  \end{block}

  \note{We need to disallow functions which don't match all patterns. Array
    access out-of-bounds, etc., also not allowed.}

  \framebreak

  We're not out of the woods yet:

  \ExecuteMetaData[BasicTypes.tex]{head2}

  \begin{block}{\alert{No!}}
    For correct proofs, all functions must be total
  \end{block}
  
  \note{To disallow \emph{this} kind of thing, we must ensure all functions are
    \emph{total}. For now, assume this means ``terminating''.}
\end{frame}
\begin{frame}
  \frametitle{Correctness}
  For the proofs to be correct, we have two extra conditions that you usually
  don't have in programming:
  
  \begin{itemize}
    \item No partial programs
    \item Only total programs
  \end{itemize}
  \note{Without these conditions, your proofs are still correct \emph{if they
      run.}}
\end{frame}
\begin{frame}
  \note{
    Enough Restrictions!

    That's a lot of things we \emph{can't} prove.

    How about something that we can?

    How about the converse?
  }
  \pause
  Can we \emph{prove} that \(\AgdaFunction{head}\) doesn't exist?

  \note{
    After all, all we have so far is ``proof by trying really hard''.
  }
\end{frame}
\begin{frame}
  \frametitle{Falsehood}
  \note{First we'll need a notion of ``False''}
  \note{Often it's said that you can't prove negatives in dependently typed
    programming: not true!}
  \note{We'll use the principle of explosion: ``A false thing is one that can be
    used to prove anything''}

  \begin{columns}
    \column{0.5\textwidth}<3->
    \ExecuteMetaData[BasicTypes.tex]{false}
    \column{0.5\textwidth}<2->
    \begin{block}{Principle of Explosion}
      \emph{``Ex falso quodlibet''} \\
      If you stand for nothing, you'll fall for anything.
    \end{block}
  \end{columns}
\end{frame}
\begin{frame}
  \ExecuteMetaData[BasicTypes.tex]{head-not}

  \note{Here's how the proof works: for falsehood, we need to prove the supplied
    proposition, no matter what it is. If \(\AgdaFunction{head}\) exists, this
    is no problem! Just get the head of a list of proofs of the proposition,
    which can be empty.}
\end{frame}
\section{A Polynomial Solver}
\section{The \(p\)-Adics}
\end{document}