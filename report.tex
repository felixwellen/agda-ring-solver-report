\documentclass[draft, twocolumn]{article}
\usepackage{cite}
\usepackage{url}
\usepackage{catchfilebetweentags}
\usepackage{amssymb}
\usepackage{turnstile}
\usepackage{bbm}
\usepackage[greek, english]{babel}
\usepackage{MnSymbol}
\newcommand\doubleplus{+\kern-1.3ex+\kern0.8ex}
\newcommand\mdoubleplus{\ensuremath{\mathbin{+\mkern-8mu+}}}
\makeatletter
\newcommand\incircbin
{%
  \mathpalette\@incircbin
}
\newcommand\@incircbin[2]
{%
  \mathbin%
  {%
    \ooalign{\hidewidth$#1#2$\hidewidth\crcr$#1\bigcirc$}%
  }%
}
\newcommand{\oeq}{\ensuremath{\incircbin{=}}}
\makeatother
\usepackage{ucs}
\DeclareUnicodeCharacter{8759}{\ensuremath{\squaredots}}
\DeclareUnicodeCharacter{951}{\textgreek{\texteta}}
\DeclareUnicodeCharacter{737}{\ensuremath{^l}}
\DeclareUnicodeCharacter{691}{\ensuremath{^r}}
\DeclareUnicodeCharacter{8718}{\ensuremath{\blacksquare}}
\DeclareUnicodeCharacter{957}{\textgreek{\textnu}}
\DeclareUnicodeCharacter{961}{\textgreek{\textrho}}
\DeclareUnicodeCharacter{954}{\textgreek{\textkappa}}
\DeclareUnicodeCharacter{10214}{\ensuremath{\lsem}}
\DeclareUnicodeCharacter{10215}{\ensuremath{\rsem}}
\DeclareUnicodeCharacter{8857}{\mdoubleplus}
\DeclareUnicodeCharacter{8860}{\oeq}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{autofe}
\usepackage{agda}
\usepackage{bbding}
\setlength{\marginparwidth}{2cm}
\usepackage[obeyDraft]{todonotes}
\author{D Ois√≠n Kidney}
\title{An Efficient and Flexible Evidence-Providing Polynomial Solver in Agda}
\begin{document}
\maketitle
\begin{abstract}
  We provide an efficient implementation of a polynomial solver in the
  programming language Agda, and demonstrate its use in a variety of
  applications.
\end{abstract}
\tableofcontents
\section{Introduction}
Dependently typed languages such as Agda\cite{norell_dependently_2008} and
Coq\cite{the_coq_development_team_2018_1219885} allow programmers to write
machine-checked proofs as programs. They provide a degree of reassurance that
handwritten proofs cannot, and allow for exploration of abstract concepts in a
machine-assisted environment.

We will describe an efficient implementation of an automated prover for
equalities in ring and ring-like structures, and show how it can be extended for
use in settings more exotic than simple equality.
\section{Monoids}
Before describing the ring solver, first we will explain the simpler case of a
monoid solver.

A monoid is a set equipped with a binary operation, \(\bullet\), and a
distinguished element \(\epsilon\), which obeys the laws:
\begin{align}
  x \bullet (y \bullet z) &= (x \bullet y) \bullet z \tag{Associativity} \\
  x \bullet \epsilon      &= x \tag{Left Identity} \\
  \epsilon \bullet x      &= x \tag{Right Identity}
\end{align}
\subsection{Equality Proofs}
Monoids can be represented in Agda in a straightforward way, as a record (see
figure~\ref{mon-def}).
\begin{figure}
  \ExecuteMetaData[Monoids.tex]{mon-def}
  \caption{The definition of Monoid in the Agda Standard
    Library\cite{danielsson_agda_2018}}
  \label{mon-def}
\end{figure}

These come equipped with their own equivalence relation, according to which
proofs for each of the monoid laws are provided. Using this, we can prove
identities like the one in figure~\ref{mon-ident}.
\begin{figure}[h]
  \ExecuteMetaData[Monoids.tex]{mon-ident}
  \caption{Example Identity}
  \label{mon-ident}
\end{figure}

While it seems like an obvious identity, the proof is somewhat involved
(figure~\ref{mon-proof}).
\begin{figure}[!h]
  \ExecuteMetaData[Monoids.tex]{mon-proof}
  \caption{Proof of identity in figure~\ref{mon-ident}}
  \label{mon-proof}
\end{figure}

The syntax mimics that of normal, handwritten proofs: the successive ``states''
of the expression are interspersed with equivalence proofs (in the brackets).
Perhaps surprisingly, the syntax is not built-in: it's simply defined in the
standard library.

Despite the powerful syntax, the proof is mechanical, and it's clear that
similar proofs would become tedious with more variables or more complex algebras
(like rings). Luckily, we can automate the procedure.
\subsection{Canonical Forms}
Automation of equality proofs like the one above can be accomplished by first
rewriting both sides of the equation into a canonical form. This form depends on
the particular algebra used in the pair of expressions. For instance, a suitable
canonical form for monoids is lists.
\ExecuteMetaData[Monoids.tex]{list-def}

This type can be thought of as an AST for the ``language of lists''. Crucially,
it's equivalent to the ``language of monoids'': this is the language of
expressions written using only variables and the monoid operations, like the
expressions in figure~\ref{mon-ident}. The neutral element and binary operator
have their equivalents in lists: \(\epsilon\) is simply the empty list, whereas
\(\bullet\) is list concatenation.
\ExecuteMetaData[Monoids.tex]{list-monoid}

We can translate between the language of lists and monoid expressions
\footnote{
  For simplicity's sake, instead of curried functions of \(n\)
  arguments, we'll deal with functions which take a vector of length \(n\), that
  refer to each variable by position, using Fin, the type of finite sets. Of
  course these two representations are equivalent, but the translation is not
  directly relevant to what we're doing here: we refer the interested reader to
  the Relation.Binary.Reflection module of Agda's standard
  library\cite{danielsson_agda_2018}.
}
with \(\mu\) and \(\eta\).
\ExecuteMetaData[Monoids.tex]{list-trans}

We have one half of the equality so far: that of the canonical forms. As such,
we have an ``obvious'' proof of the identity in figure~\ref{mon-ident},
expressed in the list language (figure~\ref{list-obvious}).
\begin{figure}[!h]
  \ExecuteMetaData[Monoids.tex]{list-obvious}
  \caption{The identity in figure~\ref{mon-ident}, expressed in the list
    language}
  \label{list-obvious}
\end{figure}
\subsection{Homomorphism}
Figure~\ref{list-obvious} gives us a proof of the form:

\begin{equation}
  \label{list-list}
  \text{lhs}_{list} = \text{rhs}_{list}
\end{equation}

What we want, though, is the following:

\begin{equation}
  \label{mon-mon}
  \text{lhs}_{mon} = \text{rhs}_{mon}
\end{equation}

Equation~\ref{list-list} can be used to build equation~\ref{mon-mon}, if we
supply two extra proofs:

\begin{equation}
  \text{lhs}_{mon} \overset{a}{=} \text{lhs}_{list} = \text{rhs}_{list}
  \overset{b}{=} \text{rhs}_{mon}
\end{equation}

The proofs labeled \(a\) and \(b\) are the task of this section.

First, we'll define a concrete AST for the monoid language
(figure~\ref{mon-ast}). It has constructors for each of the monoid operations
(\(\oplus\) and \(\text{e}\) are \(\bullet\) and \(\epsilon\), respectively),
and it's indexed by the number of variables it contains, which are constructed
with \(\nu\). Converting back to an opaque function is accomplished in
figure~\ref{eval-ast}.

\begin{figure}
  \ExecuteMetaData[Monoids.tex]{mon-ast}
  \caption{The AST for the Monoid Language}
  \label{mon-ast}
\end{figure}
\begin{figure}
  \ExecuteMetaData[Monoids.tex]{eval-ast}
  \caption{Evaluating the Monoid Language AST}
  \label{eval-ast}
\end{figure}

Finally, then, we must prove the equivalence of the monoid and list languages.
This consists of the following proofs:

\begin{align}
  (\eta x) \mu \rho           &= \left\lsem \nu x \right\rsem \rho      \\
  (x \mdoubleplus y) \mu \rho &= \left\lsem x \oplus y \right\rsem \rho \\
  [] \mu \rho                 &= \left\lsem e \right\rsem \rho
\end{align}
The latter two proofs comprise a monoid homomorphism.

The proofs are constrained: we are only permitted to use the laws provided in
the Monoid record, and the equivalence relation is kept abstract. The fact that
we're not simply using propositional equality allows for some interesting
applications (see section~\ref{setoid-applications}), but it also removes some
familiar tools we may reach for in proofs. Congruence in particular must be
specified explicitly: the combinator \(\bullet\)-cong is provided for this
purpose. With this understood, the proofs can be written:
\ExecuteMetaData[Monoids.tex]{correct-ast}
\subsection{Usage}
Combining all of the components above, with some plumbing provided by the
Relation.Binary.Reflection module, we can finally automate the solving of the
original identity in figure~\ref{mon-ident}:
\ExecuteMetaData[Monoids.tex]{ident-auto-proof}
\subsection{Reflection}
One annoyance of the automated solver is that we have to write the expression we
want to solve twice: once in the type signature, and again in the argument
supplied to solve. Agda can infer the type signature:
\ExecuteMetaData[Monoids.tex]{ident-infer-proof}
But we would prefer to write the expression in the type signature, and have it
infer the argument to solve, as the expression in the type signature is the
desired equality, and the argument to solve is something of an implementation
detail.

\todo{Fill in reflection section} This inference can be accomplished using
Agda's reflection mechanisms.
\section{A Polynomial Solver}
We now know the components required for an automatic solver for some algebra: a
canonical form, a concrete representation of expressions, and a proof of
correctness. We now turn our focus to polynomials.

Prior work in this area includes\cite{geuvers_automatically_2017},
\cite{meshveliani_dependent_2013}, \cite{zalakain_evidence-providing_2017},
\cite{cheng_functional_2018}, and \cite{russino_polynomial_2017}, but perhaps
the state-of-the-art (at least in terms of efficiency) is Coq's \texttt{ring}
tactic\cite{the_coq_development_team_2018_1219885}, which is based on an
implementation described in\cite{hutchison_proving_2005}.

That implementation has a number of optimizations which dramatically improve the
complexity of evaluation, but it also includes a careful choice of algebra which
allows for maximum reuse. The choice of algebra has been glossed over thus far,
but it is an important design decision: choose one with too many laws, and the
solver becomes unusable for several types; too few, and we may miss out on
normalization opportunities.

The algebra defined in \cite{hutchison_proving_2005} is that of an
\emph{almost-ring}. This is a ring-like algebra, which discards the requirement
that negation is an inverse (\(x + (-x) = 0\)). Instead, it merely requires that
negation distribute over addiction and multiplication appropriately. This
allows the solver to be used with non-negative types, like \(\mathbb{N}\), where
negation is simply the identity function. Also, because the implementation uses
coefficients in the underlying ring, we lose no opportunities for normalization,
as identities like \(x + (-x) = 0\) will indeed compute.
\section{Horner Normal Form}
The canonical representation of polynomials is a list of coefficients, least
significant first (``Horner Normal Form''). Our initial attempt at encoding this
representation will begin like so:
\ExecuteMetaData[Rings.tex]{dense-opening}

The entire module is parameterized by the choice of coefficient. This
coefficient should support the ring operations, but it is ``raw'', i.e. it
doesn't prove the ring laws. The operations on the polynomial itself are defined
like so:
\ExecuteMetaData[Rings.tex]{dense-impl}
\subsection{Sparse}
As it stands, the above representation has two problems:

\begin{description}
  \item[Redundancy] The representation suffers from the problem of trailing
    zeroes. In other words, the polynomial $2x$ could be represented by any of
    the following:
  
    \begin{align*}
      & 0, 2 \\
      & 0, 2, 0 \\
      & 0, 2, 0, 0 \\
      & 0, 2, 0, 0, 0, 0, 0
    \end{align*}
    
    This is a problem for a solver: the whole \emph{point} is that equivalent
    expressions are represented the same way.

  \item[Inefficiency] Expressions will tend to have large gaps, full only of
    zeroes. Something like $x^5$ will be represented as a list with 6 elements,
    only the last one being of interest. Since addition is linear in the length
    of the list, and multiplication quadratic, this is a major concern.
\end{description}

In\cite{hutchison_proving_2005}, the problem is addressed primarily from the
efficiency perspective: they add a field for the ``power index''. For our case,
we'll just store a list of pairs, where the second element of the pair is the
power index\footnote{
  In\cite{hutchison_proving_2005}, the expression \((c , i) \squaredots P\)
  represents \(P \times X^i + c\). We found that \(X^i \times (c + X \times P)\)
  is a more natural translation, and it's what we use here. A power index of
  \(i\) in this representation is equivalent to a power index of \(i+1\)
  in\cite{hutchison_proving_2005}.
}.

As an example, the polynomial:
\[ 3 + 2x^2 + 4x^5 + 2x^7 \]
Will be represented as:
\[ (3,0),(2,1),(4,2),(2,1) \]
Or, mathematically:
\[ x^0 (3 + x x^1 (2 + x x^2 * (4 + x x^1 (2 + x 0)))) \]


\section{Multivariate}
\subsection{Sparse}
\subsection{K}
\section{Setoid Applications} \label{setoid-applications}
\subsection{Traced}
\subsection{Isomorphisms}
\subsection{Counterexamples}
\section{The Correct-by-Construction Approach}
\bibliographystyle{IEEEtranS}
\bibliography{horners-rule.bib}
\end{document}